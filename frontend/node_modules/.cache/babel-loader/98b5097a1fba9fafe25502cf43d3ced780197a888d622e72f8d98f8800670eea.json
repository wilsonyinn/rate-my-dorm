{"ast":null,"code":"import { pathToRegexp } from 'path-to-regexp';\nimport invariant from 'invariant';\nexport const getItemKind = item => {\n  var _item$kind;\n  return (_item$kind = item.kind) !== null && _item$kind !== void 0 ? _item$kind : 'page';\n};\nexport const isPageItem = item => getItemKind(item) === 'page';\nexport const getItemTitle = item => {\n  var _ref, _item$title;\n  return isPageItem(item) ? (_ref = (_item$title = item.title) !== null && _item$title !== void 0 ? _item$title : item.segment) !== null && _ref !== void 0 ? _ref : '' : item.title;\n};\nexport function getPageItemFullPath(basePath, navigationItem) {\n  var _navigationItem$segme;\n  return \"\".concat(basePath).concat(basePath && !navigationItem.segment ? '' : '/').concat((_navigationItem$segme = navigationItem.segment) !== null && _navigationItem$segme !== void 0 ? _navigationItem$segme : '');\n}\nexport function isPageItemSelected(navigationItem, basePath, pathname) {\n  return navigationItem.pattern ? pathToRegexp(\"\".concat(basePath, \"/\").concat(navigationItem.pattern)).test(pathname) : getPageItemFullPath(basePath, navigationItem) === pathname;\n}\nexport function hasSelectedNavigationChildren(navigationItem, basePath, pathname) {\n  if (isPageItem(navigationItem) && navigationItem.children) {\n    const navigationItemFullPath = getPageItemFullPath(basePath, navigationItem);\n    return navigationItem.children.some(nestedNavigationItem => {\n      if (!isPageItem(nestedNavigationItem)) {\n        return false;\n      }\n      if (nestedNavigationItem.children) {\n        return hasSelectedNavigationChildren(nestedNavigationItem, navigationItemFullPath, pathname);\n      }\n      return isPageItemSelected(nestedNavigationItem, navigationItemFullPath, pathname);\n    });\n  }\n  return false;\n}\n\n/**\n * Builds a map of navigation page items to their respective paths. This map is used to quickly\n * lookup the path of a navigation item. It will be cached for the lifetime of the navigation.\n */\nfunction buildItemToPathMap(navigation) {\n  const map = new Map();\n  const visit = (item, base) => {\n    if (isPageItem(item)) {\n      const path = \"\".concat(base).concat(item.segment ? \"/\".concat(item.segment) : '') || '/';\n      map.set(item, path);\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child, path);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item, '');\n  }\n  return map;\n}\nconst itemToPathMapCache = new WeakMap();\n\n/**\n * Gets the cached map of navigation page items to their respective paths.\n */\nfunction getItemToPathMap(navigation) {\n  let map = itemToPathMapCache.get(navigation);\n  if (!map) {\n    map = buildItemToPathMap(navigation);\n    itemToPathMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Build a lookup map of paths to navigation items. This map is used to match paths against\n * to find the active page.\n */\nfunction buildItemLookup(navigation) {\n  const map = new Map();\n  const visit = item => {\n    if (isPageItem(item)) {\n      const path = getItemPath(navigation, item);\n      if (map.has(path)) {\n        console.warn(\"Duplicate path in navigation: \".concat(path));\n      }\n      map.set(path, item);\n      if (item.pattern) {\n        map.set(pathToRegexp(item.pattern), item);\n      }\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item);\n  }\n  return map;\n}\nconst itemLookupMapCache = new WeakMap();\nfunction getItemLookup(navigation) {\n  let map = itemLookupMapCache.get(navigation);\n  if (!map) {\n    map = buildItemLookup(navigation);\n    itemLookupMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Matches a path against the navigation to find the active page. i.e. the page that should be\n * marked as selected in the navigation.\n */\nexport function matchPath(navigation, path) {\n  const lookup = getItemLookup(navigation);\n  for (const [key, item] of lookup.entries()) {\n    if (typeof key === 'string' && key === path) {\n      return item;\n    }\n    if (key instanceof RegExp && key.test(path)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the path for a specific navigation page item.\n */\nexport function getItemPath(navigation, item) {\n  const map = getItemToPathMap(navigation);\n  const path = map.get(item);\n  invariant(path, \"Item not found in navigation: \".concat(item.title));\n  return path;\n}","map":{"version":3,"names":["pathToRegexp","invariant","getItemKind","item","_item$kind","kind","isPageItem","getItemTitle","_ref","_item$title","title","segment","getPageItemFullPath","basePath","navigationItem","_navigationItem$segme","concat","isPageItemSelected","pathname","pattern","test","hasSelectedNavigationChildren","children","navigationItemFullPath","some","nestedNavigationItem","buildItemToPathMap","navigation","map","Map","visit","base","path","set","child","itemToPathMapCache","WeakMap","getItemToPathMap","get","buildItemLookup","getItemPath","has","console","warn","itemLookupMapCache","getItemLookup","matchPath","lookup","key","entries","RegExp"],"sources":["/Users/wilson/Documents/rate-my-dorm/node_modules/@toolpad/core/shared/navigation.js"],"sourcesContent":["import { pathToRegexp } from 'path-to-regexp';\nimport invariant from 'invariant';\nexport const getItemKind = item => item.kind ?? 'page';\nexport const isPageItem = item => getItemKind(item) === 'page';\nexport const getItemTitle = item => {\n  return isPageItem(item) ? item.title ?? item.segment ?? '' : item.title;\n};\nexport function getPageItemFullPath(basePath, navigationItem) {\n  return `${basePath}${basePath && !navigationItem.segment ? '' : '/'}${navigationItem.segment ?? ''}`;\n}\nexport function isPageItemSelected(navigationItem, basePath, pathname) {\n  return navigationItem.pattern ? pathToRegexp(`${basePath}/${navigationItem.pattern}`).test(pathname) : getPageItemFullPath(basePath, navigationItem) === pathname;\n}\nexport function hasSelectedNavigationChildren(navigationItem, basePath, pathname) {\n  if (isPageItem(navigationItem) && navigationItem.children) {\n    const navigationItemFullPath = getPageItemFullPath(basePath, navigationItem);\n    return navigationItem.children.some(nestedNavigationItem => {\n      if (!isPageItem(nestedNavigationItem)) {\n        return false;\n      }\n      if (nestedNavigationItem.children) {\n        return hasSelectedNavigationChildren(nestedNavigationItem, navigationItemFullPath, pathname);\n      }\n      return isPageItemSelected(nestedNavigationItem, navigationItemFullPath, pathname);\n    });\n  }\n  return false;\n}\n\n/**\n * Builds a map of navigation page items to their respective paths. This map is used to quickly\n * lookup the path of a navigation item. It will be cached for the lifetime of the navigation.\n */\nfunction buildItemToPathMap(navigation) {\n  const map = new Map();\n  const visit = (item, base) => {\n    if (isPageItem(item)) {\n      const path = `${base}${item.segment ? `/${item.segment}` : ''}` || '/';\n      map.set(item, path);\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child, path);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item, '');\n  }\n  return map;\n}\nconst itemToPathMapCache = new WeakMap();\n\n/**\n * Gets the cached map of navigation page items to their respective paths.\n */\nfunction getItemToPathMap(navigation) {\n  let map = itemToPathMapCache.get(navigation);\n  if (!map) {\n    map = buildItemToPathMap(navigation);\n    itemToPathMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Build a lookup map of paths to navigation items. This map is used to match paths against\n * to find the active page.\n */\nfunction buildItemLookup(navigation) {\n  const map = new Map();\n  const visit = item => {\n    if (isPageItem(item)) {\n      const path = getItemPath(navigation, item);\n      if (map.has(path)) {\n        console.warn(`Duplicate path in navigation: ${path}`);\n      }\n      map.set(path, item);\n      if (item.pattern) {\n        map.set(pathToRegexp(item.pattern), item);\n      }\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item);\n  }\n  return map;\n}\nconst itemLookupMapCache = new WeakMap();\nfunction getItemLookup(navigation) {\n  let map = itemLookupMapCache.get(navigation);\n  if (!map) {\n    map = buildItemLookup(navigation);\n    itemLookupMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Matches a path against the navigation to find the active page. i.e. the page that should be\n * marked as selected in the navigation.\n */\nexport function matchPath(navigation, path) {\n  const lookup = getItemLookup(navigation);\n  for (const [key, item] of lookup.entries()) {\n    if (typeof key === 'string' && key === path) {\n      return item;\n    }\n    if (key instanceof RegExp && key.test(path)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the path for a specific navigation page item.\n */\nexport function getItemPath(navigation, item) {\n  const map = getItemToPathMap(navigation);\n  const path = map.get(item);\n  invariant(path, `Item not found in navigation: ${item.title}`);\n  return path;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}