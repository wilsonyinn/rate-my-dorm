{"ast":null,"code":"import { pathToRegexp } from 'path-to-regexp';\nimport invariant from 'invariant';\nexport const getItemKind = item => item.kind ?? 'page';\nexport const isPageItem = item => getItemKind(item) === 'page';\nexport const getItemTitle = item => {\n  return isPageItem(item) ? item.title ?? item.segment ?? '' : item.title;\n};\nexport function getPageItemFullPath(basePath, navigationItem) {\n  return `${basePath}${basePath && !navigationItem.segment ? '' : '/'}${navigationItem.segment ?? ''}`;\n}\nexport function isPageItemSelected(navigationItem, basePath, pathname) {\n  return navigationItem.pattern ? pathToRegexp(`${basePath}/${navigationItem.pattern}`).test(pathname) : getPageItemFullPath(basePath, navigationItem) === pathname;\n}\nexport function hasSelectedNavigationChildren(navigationItem, basePath, pathname) {\n  if (isPageItem(navigationItem) && navigationItem.children) {\n    const navigationItemFullPath = getPageItemFullPath(basePath, navigationItem);\n    return navigationItem.children.some(nestedNavigationItem => {\n      if (!isPageItem(nestedNavigationItem)) {\n        return false;\n      }\n      if (nestedNavigationItem.children) {\n        return hasSelectedNavigationChildren(nestedNavigationItem, navigationItemFullPath, pathname);\n      }\n      return isPageItemSelected(nestedNavigationItem, navigationItemFullPath, pathname);\n    });\n  }\n  return false;\n}\n\n/**\n * Builds a map of navigation page items to their respective paths. This map is used to quickly\n * lookup the path of a navigation item. It will be cached for the lifetime of the navigation.\n */\nfunction buildItemToPathMap(navigation) {\n  const map = new Map();\n  const visit = (item, base) => {\n    if (isPageItem(item)) {\n      const path = `${base}${item.segment ? `/${item.segment}` : ''}` || '/';\n      map.set(item, path);\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child, path);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item, '');\n  }\n  return map;\n}\nconst itemToPathMapCache = new WeakMap();\n\n/**\n * Gets the cached map of navigation page items to their respective paths.\n */\nfunction getItemToPathMap(navigation) {\n  let map = itemToPathMapCache.get(navigation);\n  if (!map) {\n    map = buildItemToPathMap(navigation);\n    itemToPathMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Build a lookup map of paths to navigation items. This map is used to match paths against\n * to find the active page.\n */\nfunction buildItemLookup(navigation) {\n  const map = new Map();\n  const visit = item => {\n    if (isPageItem(item)) {\n      const path = getItemPath(navigation, item);\n      if (map.has(path)) {\n        console.warn(`Duplicate path in navigation: ${path}`);\n      }\n      map.set(path, item);\n      if (item.pattern) {\n        map.set(pathToRegexp(item.pattern), item);\n      }\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item);\n  }\n  return map;\n}\nconst itemLookupMapCache = new WeakMap();\nfunction getItemLookup(navigation) {\n  let map = itemLookupMapCache.get(navigation);\n  if (!map) {\n    map = buildItemLookup(navigation);\n    itemLookupMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Matches a path against the navigation to find the active page. i.e. the page that should be\n * marked as selected in the navigation.\n */\nexport function matchPath(navigation, path) {\n  const lookup = getItemLookup(navigation);\n  for (const [key, item] of lookup.entries()) {\n    if (typeof key === 'string' && key === path) {\n      return item;\n    }\n    if (key instanceof RegExp && key.test(path)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the path for a specific navigation page item.\n */\nexport function getItemPath(navigation, item) {\n  const map = getItemToPathMap(navigation);\n  const path = map.get(item);\n  invariant(path, `Item not found in navigation: ${item.title}`);\n  return path;\n}","map":{"version":3,"names":["pathToRegexp","invariant","getItemKind","item","kind","isPageItem","getItemTitle","title","segment","getPageItemFullPath","basePath","navigationItem","isPageItemSelected","pathname","pattern","test","hasSelectedNavigationChildren","children","navigationItemFullPath","some","nestedNavigationItem","buildItemToPathMap","navigation","map","Map","visit","base","path","set","child","itemToPathMapCache","WeakMap","getItemToPathMap","get","buildItemLookup","getItemPath","has","console","warn","itemLookupMapCache","getItemLookup","matchPath","lookup","key","entries","RegExp"],"sources":["/Users/wilson/Documents/rate-my-dorm/node_modules/@toolpad/core/shared/navigation.js"],"sourcesContent":["import { pathToRegexp } from 'path-to-regexp';\nimport invariant from 'invariant';\nexport const getItemKind = item => item.kind ?? 'page';\nexport const isPageItem = item => getItemKind(item) === 'page';\nexport const getItemTitle = item => {\n  return isPageItem(item) ? item.title ?? item.segment ?? '' : item.title;\n};\nexport function getPageItemFullPath(basePath, navigationItem) {\n  return `${basePath}${basePath && !navigationItem.segment ? '' : '/'}${navigationItem.segment ?? ''}`;\n}\nexport function isPageItemSelected(navigationItem, basePath, pathname) {\n  return navigationItem.pattern ? pathToRegexp(`${basePath}/${navigationItem.pattern}`).test(pathname) : getPageItemFullPath(basePath, navigationItem) === pathname;\n}\nexport function hasSelectedNavigationChildren(navigationItem, basePath, pathname) {\n  if (isPageItem(navigationItem) && navigationItem.children) {\n    const navigationItemFullPath = getPageItemFullPath(basePath, navigationItem);\n    return navigationItem.children.some(nestedNavigationItem => {\n      if (!isPageItem(nestedNavigationItem)) {\n        return false;\n      }\n      if (nestedNavigationItem.children) {\n        return hasSelectedNavigationChildren(nestedNavigationItem, navigationItemFullPath, pathname);\n      }\n      return isPageItemSelected(nestedNavigationItem, navigationItemFullPath, pathname);\n    });\n  }\n  return false;\n}\n\n/**\n * Builds a map of navigation page items to their respective paths. This map is used to quickly\n * lookup the path of a navigation item. It will be cached for the lifetime of the navigation.\n */\nfunction buildItemToPathMap(navigation) {\n  const map = new Map();\n  const visit = (item, base) => {\n    if (isPageItem(item)) {\n      const path = `${base}${item.segment ? `/${item.segment}` : ''}` || '/';\n      map.set(item, path);\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child, path);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item, '');\n  }\n  return map;\n}\nconst itemToPathMapCache = new WeakMap();\n\n/**\n * Gets the cached map of navigation page items to their respective paths.\n */\nfunction getItemToPathMap(navigation) {\n  let map = itemToPathMapCache.get(navigation);\n  if (!map) {\n    map = buildItemToPathMap(navigation);\n    itemToPathMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Build a lookup map of paths to navigation items. This map is used to match paths against\n * to find the active page.\n */\nfunction buildItemLookup(navigation) {\n  const map = new Map();\n  const visit = item => {\n    if (isPageItem(item)) {\n      const path = getItemPath(navigation, item);\n      if (map.has(path)) {\n        console.warn(`Duplicate path in navigation: ${path}`);\n      }\n      map.set(path, item);\n      if (item.pattern) {\n        map.set(pathToRegexp(item.pattern), item);\n      }\n      if (item.children) {\n        for (const child of item.children) {\n          visit(child);\n        }\n      }\n    }\n  };\n  for (const item of navigation) {\n    visit(item);\n  }\n  return map;\n}\nconst itemLookupMapCache = new WeakMap();\nfunction getItemLookup(navigation) {\n  let map = itemLookupMapCache.get(navigation);\n  if (!map) {\n    map = buildItemLookup(navigation);\n    itemLookupMapCache.set(navigation, map);\n  }\n  return map;\n}\n\n/**\n * Matches a path against the navigation to find the active page. i.e. the page that should be\n * marked as selected in the navigation.\n */\nexport function matchPath(navigation, path) {\n  const lookup = getItemLookup(navigation);\n  for (const [key, item] of lookup.entries()) {\n    if (typeof key === 'string' && key === path) {\n      return item;\n    }\n    if (key instanceof RegExp && key.test(path)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the path for a specific navigation page item.\n */\nexport function getItemPath(navigation, item) {\n  const map = getItemToPathMap(navigation);\n  const path = map.get(item);\n  invariant(path, `Item not found in navigation: ${item.title}`);\n  return path;\n}"],"mappings":"AAAA,SAASA,YAAY,QAAQ,gBAAgB;AAC7C,OAAOC,SAAS,MAAM,WAAW;AACjC,OAAO,MAAMC,WAAW,GAAGC,IAAI,IAAIA,IAAI,CAACC,IAAI,IAAI,MAAM;AACtD,OAAO,MAAMC,UAAU,GAAGF,IAAI,IAAID,WAAW,CAACC,IAAI,CAAC,KAAK,MAAM;AAC9D,OAAO,MAAMG,YAAY,GAAGH,IAAI,IAAI;EAClC,OAAOE,UAAU,CAACF,IAAI,CAAC,GAAGA,IAAI,CAACI,KAAK,IAAIJ,IAAI,CAACK,OAAO,IAAI,EAAE,GAAGL,IAAI,CAACI,KAAK;AACzE,CAAC;AACD,OAAO,SAASE,mBAAmBA,CAACC,QAAQ,EAAEC,cAAc,EAAE;EAC5D,OAAO,GAAGD,QAAQ,GAAGA,QAAQ,IAAI,CAACC,cAAc,CAACH,OAAO,GAAG,EAAE,GAAG,GAAG,GAAGG,cAAc,CAACH,OAAO,IAAI,EAAE,EAAE;AACtG;AACA,OAAO,SAASI,kBAAkBA,CAACD,cAAc,EAAED,QAAQ,EAAEG,QAAQ,EAAE;EACrE,OAAOF,cAAc,CAACG,OAAO,GAAGd,YAAY,CAAC,GAAGU,QAAQ,IAAIC,cAAc,CAACG,OAAO,EAAE,CAAC,CAACC,IAAI,CAACF,QAAQ,CAAC,GAAGJ,mBAAmB,CAACC,QAAQ,EAAEC,cAAc,CAAC,KAAKE,QAAQ;AACnK;AACA,OAAO,SAASG,6BAA6BA,CAACL,cAAc,EAAED,QAAQ,EAAEG,QAAQ,EAAE;EAChF,IAAIR,UAAU,CAACM,cAAc,CAAC,IAAIA,cAAc,CAACM,QAAQ,EAAE;IACzD,MAAMC,sBAAsB,GAAGT,mBAAmB,CAACC,QAAQ,EAAEC,cAAc,CAAC;IAC5E,OAAOA,cAAc,CAACM,QAAQ,CAACE,IAAI,CAACC,oBAAoB,IAAI;MAC1D,IAAI,CAACf,UAAU,CAACe,oBAAoB,CAAC,EAAE;QACrC,OAAO,KAAK;MACd;MACA,IAAIA,oBAAoB,CAACH,QAAQ,EAAE;QACjC,OAAOD,6BAA6B,CAACI,oBAAoB,EAAEF,sBAAsB,EAAEL,QAAQ,CAAC;MAC9F;MACA,OAAOD,kBAAkB,CAACQ,oBAAoB,EAAEF,sBAAsB,EAAEL,QAAQ,CAAC;IACnF,CAAC,CAAC;EACJ;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA,SAASQ,kBAAkBA,CAACC,UAAU,EAAE;EACtC,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrB,MAAMC,KAAK,GAAGA,CAACtB,IAAI,EAAEuB,IAAI,KAAK;IAC5B,IAAIrB,UAAU,CAACF,IAAI,CAAC,EAAE;MACpB,MAAMwB,IAAI,GAAG,GAAGD,IAAI,GAAGvB,IAAI,CAACK,OAAO,GAAG,IAAIL,IAAI,CAACK,OAAO,EAAE,GAAG,EAAE,EAAE,IAAI,GAAG;MACtEe,GAAG,CAACK,GAAG,CAACzB,IAAI,EAAEwB,IAAI,CAAC;MACnB,IAAIxB,IAAI,CAACc,QAAQ,EAAE;QACjB,KAAK,MAAMY,KAAK,IAAI1B,IAAI,CAACc,QAAQ,EAAE;UACjCQ,KAAK,CAACI,KAAK,EAAEF,IAAI,CAAC;QACpB;MACF;IACF;EACF,CAAC;EACD,KAAK,MAAMxB,IAAI,IAAImB,UAAU,EAAE;IAC7BG,KAAK,CAACtB,IAAI,EAAE,EAAE,CAAC;EACjB;EACA,OAAOoB,GAAG;AACZ;AACA,MAAMO,kBAAkB,GAAG,IAAIC,OAAO,CAAC,CAAC;;AAExC;AACA;AACA;AACA,SAASC,gBAAgBA,CAACV,UAAU,EAAE;EACpC,IAAIC,GAAG,GAAGO,kBAAkB,CAACG,GAAG,CAACX,UAAU,CAAC;EAC5C,IAAI,CAACC,GAAG,EAAE;IACRA,GAAG,GAAGF,kBAAkB,CAACC,UAAU,CAAC;IACpCQ,kBAAkB,CAACF,GAAG,CAACN,UAAU,EAAEC,GAAG,CAAC;EACzC;EACA,OAAOA,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA,SAASW,eAAeA,CAACZ,UAAU,EAAE;EACnC,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrB,MAAMC,KAAK,GAAGtB,IAAI,IAAI;IACpB,IAAIE,UAAU,CAACF,IAAI,CAAC,EAAE;MACpB,MAAMwB,IAAI,GAAGQ,WAAW,CAACb,UAAU,EAAEnB,IAAI,CAAC;MAC1C,IAAIoB,GAAG,CAACa,GAAG,CAACT,IAAI,CAAC,EAAE;QACjBU,OAAO,CAACC,IAAI,CAAC,iCAAiCX,IAAI,EAAE,CAAC;MACvD;MACAJ,GAAG,CAACK,GAAG,CAACD,IAAI,EAAExB,IAAI,CAAC;MACnB,IAAIA,IAAI,CAACW,OAAO,EAAE;QAChBS,GAAG,CAACK,GAAG,CAAC5B,YAAY,CAACG,IAAI,CAACW,OAAO,CAAC,EAAEX,IAAI,CAAC;MAC3C;MACA,IAAIA,IAAI,CAACc,QAAQ,EAAE;QACjB,KAAK,MAAMY,KAAK,IAAI1B,IAAI,CAACc,QAAQ,EAAE;UACjCQ,KAAK,CAACI,KAAK,CAAC;QACd;MACF;IACF;EACF,CAAC;EACD,KAAK,MAAM1B,IAAI,IAAImB,UAAU,EAAE;IAC7BG,KAAK,CAACtB,IAAI,CAAC;EACb;EACA,OAAOoB,GAAG;AACZ;AACA,MAAMgB,kBAAkB,GAAG,IAAIR,OAAO,CAAC,CAAC;AACxC,SAASS,aAAaA,CAAClB,UAAU,EAAE;EACjC,IAAIC,GAAG,GAAGgB,kBAAkB,CAACN,GAAG,CAACX,UAAU,CAAC;EAC5C,IAAI,CAACC,GAAG,EAAE;IACRA,GAAG,GAAGW,eAAe,CAACZ,UAAU,CAAC;IACjCiB,kBAAkB,CAACX,GAAG,CAACN,UAAU,EAAEC,GAAG,CAAC;EACzC;EACA,OAAOA,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASkB,SAASA,CAACnB,UAAU,EAAEK,IAAI,EAAE;EAC1C,MAAMe,MAAM,GAAGF,aAAa,CAAClB,UAAU,CAAC;EACxC,KAAK,MAAM,CAACqB,GAAG,EAAExC,IAAI,CAAC,IAAIuC,MAAM,CAACE,OAAO,CAAC,CAAC,EAAE;IAC1C,IAAI,OAAOD,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAKhB,IAAI,EAAE;MAC3C,OAAOxB,IAAI;IACb;IACA,IAAIwC,GAAG,YAAYE,MAAM,IAAIF,GAAG,CAAC5B,IAAI,CAACY,IAAI,CAAC,EAAE;MAC3C,OAAOxB,IAAI;IACb;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA,OAAO,SAASgC,WAAWA,CAACb,UAAU,EAAEnB,IAAI,EAAE;EAC5C,MAAMoB,GAAG,GAAGS,gBAAgB,CAACV,UAAU,CAAC;EACxC,MAAMK,IAAI,GAAGJ,GAAG,CAACU,GAAG,CAAC9B,IAAI,CAAC;EAC1BF,SAAS,CAAC0B,IAAI,EAAE,iCAAiCxB,IAAI,CAACI,KAAK,EAAE,CAAC;EAC9D,OAAOoB,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}